schema_version: "0.3.0"
pattern_version: "1.0.0"
id: "ACME.PLT:ANTI:RATELIMIT:INMEM"
type: "ANTI"
title: "In-Memory Rate Limiting Anti-Pattern"
summary: "Storing rate limit counters in application memory causes issues in distributed systems"

scope:
  languages: ["javascript", "python", "java"]
  frameworks: ["express", "fastapi", "spring"]
  task_types: ["rate-limiting", "api-protection"]
  envs: ["production"]

snippets:
  - label: "Problematic in-memory implementation"
    language: "javascript"
    code: |
      // ❌ ANTI-PATTERN: Don't do this!
      const requestCounts = new Map();
      
      function rateLimiter(maxRequests, windowMs) {
        return (req, res, next) => {
          const key = `${req.ip}:${req.path}`;
          const now = Date.now();
          
          if (!requestCounts.has(key)) {
            requestCounts.set(key, []);
          }
          
          const requests = requestCounts.get(key);
          const recentRequests = requests.filter(time => now - time < windowMs);
          
          if (recentRequests.length >= maxRequests) {
            return res.status(429).json({ error: 'Too many requests' });
          }
          
          recentRequests.push(now);
          requestCounts.set(key, recentRequests);
          
          // Memory leak: Map grows indefinitely!
          next();
        };
      }
    source_ref:
      kind: "git_lines"
      file: "src/middleware/badRateLimiter.js"
      sha: "def789abc123"
      start: 5
      end: 28

  - label: "Issues with this approach"
    language: "markdown"
    code: |
      ## Problems:
      
      1. **Not distributed**: Each server instance has its own counters
         - User can hit rate limit × number of servers
         - Load balancer can be gamed by reconnecting
      
      2. **Memory leaks**: Map grows indefinitely without cleanup
         - No TTL on entries
         - Can cause OOM errors
      
      3. **Lost on restart**: All rate limit data lost when server restarts
         - Allows burst attacks after deployments
         - No persistence across releases
      
      4. **No shared state**: Cannot coordinate across services
         - Microservices can't share rate limits
         - API gateway can't enforce global limits

evidence:
  - kind: "issue"
    id: "INC-2341"
    system: "jira"
  - kind: "pr"
    number: 456
    repo: "acme/api-server"
  - kind: "git_lines"
    file: "docs/postmortem/2024-11-outage.md"
    sha: "abc456def789"
    start: 45
    end: 67

usage:
  successes: 0
  failures: 8
  last_used_at: "2024-11-15T22:45:00Z"

trust_score: 0.1
created_at: "2024-11-20T09:00:00Z"
updated_at: "2024-12-01T14:30:00Z"
source_repo: "acme/api-server"
tags: ["anti-pattern", "memory-leak", "distributed-systems", "security"]

deprecated:
  reason: "Causes memory leaks and doesn't work in distributed systems"
  replaced_by: "ACME.PLT:LANG:RATELIMIT:REDIS"

notes: |
  This anti-pattern was discovered after a production incident where memory usage
  grew unbounded and rate limiting was ineffective across our Kubernetes pods.
  Always use external storage (Redis, DynamoDB, etc.) for rate limiting state.